/*=========================================================================

 Program: FEMUS
 Module: GambitIO
 Authors: Simone Bn√†

 Copyright (c) FEMTTU
 All rights reserved.

 This software is distributed WITHOUT ANY WARRANTY; without even
 the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

//local include
#include "GambitIO.hpp"
#include "Mesh.hpp"

//C++ include
#include "cstdio"
#include "fstream"


/** The Geometric Element types that can potentially be generated by Gambit are as follows
 * (for each, we say if we support the mesh reading):
 * 
 * 1D:
 * Edge, 2 nodes
 * Edge, 3 nodes  (supported)
 * 
 * 2D:
 * Quadrilateral: 4 nodes
 * Quadrilateral: 8 nodes
 * Quadrilateral: 9 nodes  (supported)
 * Triangle: 3 nodes
 * Triangle: 6 nodes  (supported)
 * 
 * 3D:
 * Hexahedron: 8 nodes
 * Hexahedron: 20 nodes
 * Hexahedron: 27 nodes  (supported)
 * Tetrahedron: 4 nodes
 * Tetrahedron: 10 nodes  (supported)
 * Wedge: 6 nodes
 * Wedge: 15 nodes
 * Wedge: 18 nodes  (supported)
 * Pyramid: 5 nodes
 * Pyramid: 13 nodes
 * Pyramid: 14 nodes
 * 
*/

namespace femus {

  const unsigned GambitIO::GambitToFemusVertexIndex[N_GEOM_ELS][MAX_EL_N_NODES] = {
    {//hex27
      4, 16, 0, 15, 23, 11, 7, 19, 3,
      12, 20, 8, 25, 26, 24, 14, 22, 10,
      5, 17, 1, 13, 21, 9, 6, 18, 2
    },
    {//tet10
      0, 4, 1, 6, 5,
      2, 7, 8, 9, 3
    },
    {//wedge18
      3, 11, 5, 9, 10, 4,
      12, 17, 14, 15, 16, 13,
      0, 8, 2, 6, 7, 1
    },
    { //quad9
      0, 4, 1, 5, 2, 6, 3, 7, 8
    },
    { //tri7
      0, 3, 1, 4, 2, 5, 6 ///@todo does Gambit have Tri7 elements???, not really, in fact below we don't use it...
    },
    { //edge3
      0, 2, 1
    }
  };


  const unsigned GambitIO::GambitToFemusFaceIndex[N_GEOM_ELS][MAX_EL_N_FACES] = {
    {0, 4, 2, 5, 3, 1}, //hex
    {0, 1, 2, 3},       //tet
    {2, 1, 0, 4, 3},    //wedge
    {0, 1, 2, 3},       //quad
    {0, 1, 2},          //tri
    {0, 1}              //edge
  };

 


  void GambitIO::read(const std::string& name, std::vector < std::vector < double> > &coords, const double Lref, std::vector<bool> &type_elem_flag, const bool read_groups, const bool read_boundary_groups) {

    Mesh& mesh = GetMesh();

    std::ifstream inf;
    std::string str2;
    unsigned ngroup;
    unsigned nbcd;
    unsigned dim;       //dimension of the Geometric Elements
    unsigned dimNodes;  //number of coordinates provided: it could be different if you have say 2D elements in 3d
    double x, y, z;
    
    unsigned nvt;
    unsigned nel;

    mesh.SetLevel(0);

    
    // read control data - BEGIN ******************** A
    
    inf.open(name.c_str());
    if(!inf) {
      std::cout << "Generic-mesh file " << name << " can not read parameters\n";
      exit(0);
    }
    str2 = "0";
    while(str2.compare("NDFVL") != 0) inf >> str2;
    inf >> nvt >> nel >>  ngroup >> nbcd >> dim >> dimNodes ;

    inf >> str2;
    if(str2.compare("ENDOFSECTION") != 0) {
      std::cout << "error control data mesh" << std::endl;
      exit(0);
    }
//   std::cout << "***************" << _dimension << std::endl;
    inf.close();
    
    // read control data - END **************** A   
    
    
    // Mesh, dimension - BEGIN ********************
    mesh.SetDimension(dim);
    // Mesh, dimension - END ********************
    
    // geom el, refinement - BEGIN ********************
    mesh.SetRefinementCellAndFaceIndices(dim);
    // geom el, refinement - END ******************** 
    
    // Mesh, Elements - BEGIN ********************
    mesh.SetNumberOfElements(nel);
    // Mesh, Elements - END ********************
    
    // Mesh, Nodes - BEGIN ********************
    mesh.SetNumberOfNodes(nvt);
    // Mesh, Nodes - END ********************
    


    
    // read ELEMENT/CELL - BEGIN ******************** B
    inf.open(name.c_str());
    if(!inf) {
      std::cout << "Generic-mesh file " << name << " cannot read elements\n";
      exit(0);
    }
    mesh.el = new elem(nel, mesh.GetDimension());
    while(str2.compare("ELEMENTS/CELLS") != 0) inf >> str2;
    inf >> str2;
    
    for(unsigned iel = 0; iel < nel; iel++) {
      
      
      unsigned nve;
      inf >> str2 >> str2 >> nve;
      
      if(nve == 27) {
        type_elem_flag[0] = type_elem_flag[3] = true;
        mesh.el->AddToElementNumber(1, "Hex");
        mesh.el->SetElementType(iel, HEX);
      }
      
      else if(nve == 10) {
        type_elem_flag[1] = type_elem_flag[4] = true;
        mesh.el->AddToElementNumber(1, "Tet");
        mesh.el->SetElementType(iel, TET);
      }
      
      else if(nve == 18) {
        type_elem_flag[2] = type_elem_flag[3] = type_elem_flag[4] = true;
        mesh.el->AddToElementNumber(1, "Wedge");
        mesh.el->SetElementType(iel, WEDGE);
      }
      
      else if(nve == 9) {
        type_elem_flag[3] = true;
        mesh.el->AddToElementNumber(1, "Quad");
        mesh.el->SetElementType(iel, QUAD);
      }
      
      else if(mesh.GetDimension() == 2 && nve == 6) {
        type_elem_flag[4] = true;
        mesh.el->AddToElementNumber(1, "Triangle");
        mesh.el->SetElementType(iel, TRI);
      }
      
      else if(mesh.GetDimension() == 1 && nve == 3) {
        mesh.el->AddToElementNumber(1, "Line");
        mesh.el->SetElementType(iel, LINE);
      }

      else {
        std::cout << "Error! Invalid element type in reading Gambit File!" << std::endl;
        std::cout << "Error! Use a second order discretization" << std::endl;
        exit(0);
      }
      
      for(unsigned i = 0; i < nve; i++) {
        unsigned inode = GambitIO::GambitToFemusVertexIndex[mesh.el->GetElementType(iel)][i];
        unsigned value;
        inf >> value;
        mesh.el->SetElementDofIndex(iel, inode, value - 1u);
      }
    }
    
       
    inf >> str2;
    if(str2.compare("ENDOFSECTION") != 0) {
      std::cout << "error element data mesh" << std::endl;
      exit(0);
    }
    inf.close();

    // read ELEMENT/CELL - END **************** B

    

    // read NODAL COORDINATES - BEGIN  **************** C
    inf.open(name.c_str());
    if(!inf) {
      std::cout << "Generic-mesh file " << name << " cannot read nodes\n";
      exit(0);
    }
    while(str2.compare("COORDINATES") != 0) inf >> str2;
    inf >> str2;  // 2.0.4
    coords[0].resize(nvt);
    coords[1].resize(nvt);
    coords[2].resize(nvt);

    if(dimNodes == 3) {
      for(unsigned j = 0; j < nvt; j++) {
        inf >> str2 >> x >> y >> z;
        coords[0][j] = x / Lref;
        coords[1][j] = y / Lref;
        coords[2][j] = z / Lref;
      }
    }
    else if(dimNodes == 2) {
      for(unsigned j = 0; j < nvt; j++) {
        inf >> str2 >> x >> y;
        coords[0][j] = x / Lref;
        coords[1][j] = y / Lref;
        coords[2][j] = 0.;
      }
    }
    else if(dimNodes == 1) {
      for(unsigned j = 0; j < nvt; j++) {
        inf >> str2 >> x;
        coords[0][j] = x / Lref;
        coords[1][j] = 0.;
        coords[2][j] = 0.;
      }
    }
    inf >> str2; // "ENDOFSECTION"
    if(str2.compare("ENDOFSECTION") != 0) {
      std::cout << "error node data mesh 1" << std::endl;
      exit(0);
    }
    
    
    inf.close();
    // read NODAL COORDINATES - END ************* C

    
    
    
    // Initialize GROUP - BEGIN  **************** C
     for(unsigned iel = 0; iel < nel; iel++) {
         mesh.el->SetElementGroup(iel, 1);
      }
    // Initialize GROUP - END **************** C
    
    
    
    // read GROUP - BEGIN  **************** E
    inf.open(name.c_str());
    if(!inf) {
      std::cout << "Generic-mesh file " << name << " cannot read group\n";
      exit(0);
    }
    std::vector < unsigned > materialElementCounter(3,0);
    mesh.el->SetElementGroupNumber(ngroup);
    for(unsigned k = 0; k < ngroup; k++) {
      int ngel;
      int gr_name;
      int gr_mat;
      while(str2.compare("GROUP:") != 0) inf >> str2;
      inf >> str2 >> str2 >> ngel >> str2 >> gr_mat >> str2 >> str2 >> gr_name >> str2;
      for(int i = 0; i < ngel; i++) {
        int iel;
        inf >> iel;
        mesh.el->SetElementGroup(iel - 1, gr_name);
        mesh.el->SetElementMaterial(iel - 1, gr_mat);
	if( gr_mat == 2) materialElementCounter[0] += 1;
	else if(gr_mat == 3 ) materialElementCounter[1] += 1;
	else materialElementCounter[2] += 1;
      }
      inf >> str2;
      if(str2.compare("ENDOFSECTION") != 0) {
        std::cout << "error group data mesh" << std::endl;
        exit(0);
      }
    }
    mesh.el->SetMaterialElementCounter(materialElementCounter);
    inf.close();
    // read GROUP - END **************** E


    // read boundary - BEGIN  **************** D
    inf.open(name.c_str());
    if(!inf) {
      std::cout << "Generic-mesh file " << name << " cannot read boudary\n";
      exit(0);
    }
    for(unsigned k = 0; k < nbcd; k++) {
      while(str2.compare("CONDITIONS") != 0) inf >> str2;
      inf >> str2;
      int value;
      unsigned nface;
      inf >> value >> str2 >> nface >> str2 >> str2;
      value = -value - 1;
      for(unsigned i = 0; i < nface; i++) {
        unsigned iel, iface;
        inf >> iel >> str2 >> iface;
        iel--;
        iface = GambitIO::GambitToFemusFaceIndex[mesh.el->GetElementType(iel)][iface - 1u];
        mesh.el->SetFaceElementIndex(iel, iface, value);
      }
      inf >> str2;
      if(str2.compare("ENDOFSECTION") != 0) {
        std::cout << "error boundary data mesh" << std::endl;
        exit(0);
      }
    }
    inf.close();
    // read boundary - END **************** D

  };
  
   
}
